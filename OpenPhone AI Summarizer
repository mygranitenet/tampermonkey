// ==UserScript==
// @name         OpenPhone AI Summarizer (with Export & Time Frame)
// @namespace    https://openphone.com/
// @version      1.1.0
// @description  Summarize OpenPhone conversations with AI, now with export to ZIP and time frame selection
// @match        https://my.openphone.com/*
// @icon         https://www.google.com/s2/favicons?domain=openphone.com
// @grant        none
// @require      https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js
// ==/UserScript==

(function() {
    'use strict';

    // Utility: Determine current conversation ID from the URL (or page context)
    function getCurrentConversationId() {
        // Attempt to parse conversation ID from URL (assuming URL contains "conversation/<id>")
        const hash = window.location.hash || window.location.pathname;
        let match = hash.match(/conversation[s]?\/([^\/]+)/);
        return match ? match[1] : null;
    }

    // Utility: Calculate start/end timestamps for the given time frame selection
    function getTimeFrameBounds(frame) {
        const now = new Date();
        let start = null, end = null;
        switch(frame) {
            case 'today':
                // start of today (midnight)
                start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                end = now;  // end is now (implicitly include everything up to current time)
                break;
            case 'yesterday':
                // yesterday: from yesterday 00:00 to today 00:00
                start = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
                end = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                break;
            case 'thisWeek':
                // this week: from Monday of current week to now
                const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, ... 6 = Saturday
                const mondayOffset = (dayOfWeek === 0 ? 6 : dayOfWeek - 1);  // how many days to subtract to get Monday
                start = new Date(now);
                start.setHours(0, 0, 0, 0);
                start.setDate(now.getDate() - mondayOffset);
                end = now;
                break;
            case 'lastWeek':
                // last week: from Monday of last week to Monday of this week
                const day = now.getDay();
                const offset = (day === 0 ? 6 : day - 1);
                const mondayThisWeek = new Date(now);
                mondayThisWeek.setHours(0, 0, 0, 0);
                mondayThisWeek.setDate(now.getDate() - offset);
                end = new Date(mondayThisWeek);             // end at start of this week
                start = new Date(mondayThisWeek);
                start.setDate(start.getDate() - 7);         // start at one week before this week
                break;
            case 'all':
            default:
                // No filtering
                start = null;
                end = null;
                break;
        }
        return { start, end };
    }

    // Utility: Gather all summary sections text from the output container (for full export)
    function getAllSectionsText(containerElem) {
        let textContent = "";
        // Loop through child nodes to preserve structure and headers
        containerElem.childNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
                const tag = node.tagName.toLowerCase();
                if (tag === 'h1' || tag === 'h2' || tag === 'h3' || tag === 'h4' || tag === 'h5' || tag === 'h6') {
                    // Headings: include text with a colon
                    textContent += node.innerText.trim() + ":\n";
                } else {
                    // Other element (paragraph, div, etc): append its text
                    textContent += node.innerText.trim() + "\n";
                }
            } else if (node.nodeType === Node.TEXT_NODE) {
                // Plain text node (unlikely outside of elements, but just in case)
                const txt = node.textContent.trim();
                if (txt) textContent += txt + "\n";
            }
        });
        return textContent.trim();
    }

    // Main: Insert a "Summarize" button into the OpenPhone UI if not already present
    function insertSummarizeButton() {
        // For example, append to conversation header or toolbar
        const convoHeader = document.querySelector('[class*="ConversationHeader"], [class*="conversation-header"]');  // try to find conversation header element
        if (convoHeader && !document.getElementById('openphone-summarize-btn')) {
            const btn = document.createElement('button');
            btn.id = 'openphone-summarize-btn';
            btn.textContent = 'Summarize';
            btn.style.marginLeft = '8px';
            // Minimal styling to match UI (you can adjust as needed)
            btn.style.cursor = 'pointer';
            convoHeader.appendChild(btn);

            // On click, open the summarizer modal for the current conversation
            btn.addEventListener('click', () => {
                const convId = getCurrentConversationId();
                if (!convId) {
                    alert("Unable to determine conversation ID.");
                    return;
                }
                openSummarizerModal(convId);
            });
        }
    }

    // Function: Open the summarizer modal UI
    function openSummarizerModal(conversationId) {
        // Create overlay background
        const overlay = document.createElement('div');
        overlay.id = 'summarizerOverlay';
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.background = 'rgba(0,0,0,0.5)';
        overlay.style.zIndex = '10000';
        document.body.appendChild(overlay);

        // Create modal container
        const modal = document.createElement('div');
        modal.id = 'summarizerModal';
        modal.style.position = 'fixed';
        modal.style.top = '50%';
        modal.style.left = '50%';
        modal.style.transform = 'translate(-50%, -50%)';
        modal.style.maxWidth = '600px';
        modal.style.width = '90%';
        modal.style.background = '#fff';
        modal.style.border = '1px solid #888';
        modal.style.borderRadius = '4px';
        modal.style.padding = '16px';
        modal.style.zIndex = '10001';
        modal.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
        document.body.appendChild(modal);

        // Modal inner HTML structure
        modal.innerHTML = `
            <h2 style="margin-top: 0;">Conversation Summary</h2>
            <!-- Time Frame selector + Generate button -->
            <div style="margin-bottom: 8px;">
                <label for="timeFrameSelect" style="font-weight: 500; margin-right:4px;">Time Frame:</label>
                <select id="timeFrameSelect" style="padding: 2px 4px; margin-right: 8px;">
                    <option value="all" selected>All</option>
                    <option value="today">Today</option>
                    <option value="yesterday">Yesterday</option>
                    <option value="thisWeek">This Week</option>
                    <option value="lastWeek">Last Week</option>
                </select>
                <button id="generateSummaryBtn" style="padding: 4px 8px;">Generate Summary</button>
            </div>
            <!-- Summary output area -->
            <div id="summaryOutput" style="white-space: pre-line; overflow-y: auto; max-height: 300px; border: 1px solid #ddd; padding: 8px; margin-bottom: 8px;"></div>
            <!-- Export controls (hidden until summary generated) -->
            <div id="exportControls" style="display: none; margin-bottom: 8px;">
                <label for="exportSelect" style="font-weight: 500; margin-right:4px;">Export:</label>
                <select id="exportSelect" style="padding: 2px 4px; margin-right: 8px;">
                    <option value="full" selected>All Sections</option>
                    <option value="quick">Quick Summary only</option>
                </select>
                <button id="downloadZipBtn" style="padding: 4px 8px;">Download ZIP</button>
            </div>
            <button id="closeSummaryBtn" style="padding: 4px 8px; float: right;">Close</button>
        `;

        // Event: Close modal when "Close" button or overlay is clicked
        const closeBtn = document.getElementById('closeSummaryBtn');
        closeBtn.addEventListener('click', closeModal);
        overlay.addEventListener('click', closeModal);
        function closeModal() {
            document.body.removeChild(modal);
            document.body.removeChild(overlay);
        }

        // Event: Generate summary when "Generate Summary" button is clicked
        const generateBtn = document.getElementById('generateSummaryBtn');
        generateBtn.addEventListener('click', async () => {
            generateBtn.disabled = true;
            document.getElementById('summaryOutput').innerText = "Generating summary...";  // simple loading state
            try {
                await generateSummary(conversationId);
            } finally {
                generateBtn.disabled = false;
            }
        });

        // Event: Download ZIP when "Download ZIP" button is clicked
        document.getElementById('downloadZipBtn').addEventListener('click', downloadSummaryZip);
    }

    // Function: Fetch conversation data, filter by time frame, call AI to summarize, and display results
    async function generateSummary(conversationId) {
        const outputDiv = document.getElementById('summaryOutput');
        const frame = document.getElementById('timeFrameSelect').value;
        const { start, end } = getTimeFrameBounds(frame);
        let conversationData = [];

        try {
            // Fetch conversation activity (messages, calls, etc.) via OpenPhone API
            const resp = await fetch(`/v2/activity?id=${conversationId}`);
            if (!resp.ok) throw new Error(`API request failed with status ${resp.status}`);
            const data = await resp.json();
            conversationData = Array.isArray(data) ? data : data.data || [];

            // Apply time frame filtering if needed
            if (start || end) {
                conversationData = conversationData.filter(item => {
                    if (!item.createdAt) return false;
                    const itemTime = new Date(item.createdAt);
                    if (start && itemTime < start) return false;
                    if (end && itemTime >= end) return false;
                    return true;
                });
            }
        } catch (err) {
            console.error("Error fetching conversation data:", err);
            outputDiv.innerText = "❌ Failed to retrieve conversation data.";
            return;
        }

        // Call AI summarization (this function would use an AI API or OpenPhone's AI to summarize the data)
        let summaryResult;
        try {
            summaryResult = await summarizeConversation(conversationData);  // Placeholder for actual AI call
        } catch (err) {
            console.error("AI summarization error:", err);
            outputDiv.innerText = "❌ Failed to generate summary.";
            return;
        }

        // Display the summary result in the modal
        outputDiv.innerHTML = "";  // clear previous content
        window._lastSummaryTitle = "";  // reset last title

        if (summaryResult) {
            // If the result is structured (object with sections) vs plain text
            if (typeof summaryResult === 'object') {
                // If an AI title is provided, we store it for file naming (not necessarily displayed)
                if (summaryResult.title) {
                    window._lastSummaryTitle = summaryResult.title;
                    // Optionally, display the title in the modal (for context)
                    // outputDiv.innerHTML += `<h3>${summaryResult.title}</h3>`;
                }
                // Append Quick Summary section if present
                if (summaryResult.quickSummary) {
                    const sec = document.createElement('div');
                    const h = document.createElement('h3');
                    h.innerText = "Quick Summary";
                    const p = document.createElement('p');
                    p.innerText = summaryResult.quickSummary;
                    sec.appendChild(h);
                    sec.appendChild(p);
                    outputDiv.appendChild(sec);
                }
                // Append other sections if present (e.g., detailed summary, action items)
                if (summaryResult.detailedSummary) {
                    const sec = document.createElement('div');
                    const h = document.createElement('h3');
                    h.innerText = "Detailed Summary";
                    const p = document.createElement('p');
                    p.innerText = summaryResult.detailedSummary;
                    sec.appendChild(h);
                    sec.appendChild(p);
                    outputDiv.appendChild(sec);
                }
                if (summaryResult.actionItems) {
                    const sec = document.createElement('div');
                    const h = document.createElement('h3');
                    h.innerText = "Action Items";
                    const p = document.createElement('p');
                    p.innerText = summaryResult.actionItems;
                    sec.appendChild(h);
                    sec.appendChild(p);
                    outputDiv.appendChild(sec);
                }
                // (Add handling for any other sections the AI might return)
            } else {
                // summaryResult is plain text (string)
                outputDiv.innerText = summaryResult;
            }
        } else {
            outputDiv.innerText = "(No summary available.)";
        }

        // Show the export controls now that summary is ready
        document.getElementById('exportControls').style.display = 'block';
    }

    // Function: Download the summary as a ZIP file (called on "Download ZIP" button click)
    function downloadSummaryZip() {
        const outputDiv = document.getElementById('summaryOutput');
        if (!outputDiv || outputDiv.innerText.trim() === "") {
            alert("No summary available to export.");
            return;
        }
        const exportOption = document.getElementById('exportSelect').value;
        let textContent = "";

        if (exportOption === 'quick') {
            // Quick Summary only: find the first section that is Quick Summary
            const quickSectionHeader = outputDiv.querySelector('h3');
            if (quickSectionHeader && quickSectionHeader.innerText.includes("Quick Summary")) {
                // Get the text of the quick summary section
                let qsText = "";
                // If the structure is a <div> containing h3 + p, we can get the parent div's text
                const sectionDiv = quickSectionHeader.parentElement;
                qsText = sectionDiv ? sectionDiv.innerText : quickSectionHeader.innerText;
                // Remove the heading from the text (to avoid duplicating heading line if innerText includes it)
                qsText = qsText.replace(/^Quick Summary\s*/i, "").trim();
                textContent = "Quick Summary:\n" + qsText;
            } else {
                // Fallback: no explicit section, use entire text (assuming it's already just one summary)
                textContent = outputDiv.innerText;
            }
        } else {
            // Full export: all sections
            textContent = getAllSectionsText(outputDiv);
        }

        // Prepare the ZIP with the text file
        const zip = new JSZip();
        // Determine base filename (use AI title if available, else default)
        let baseName = "conversation-summary";
        if (window._lastSummaryTitle && window._lastSummaryTitle.trim() !== "") {
            // Sanitize title for filesystem (replace forbidden chars with underscores)
            baseName = window._lastSummaryTitle.trim().replace(/[\/\\|:*?"<>]/g, "_");
        }
        const now = new Date();
        const hh = String(now.getHours()).padStart(2, '0');
        const mm = String(now.getMinutes()).padStart(2, '0');
        const ss = String(now.getSeconds()).padStart(2, '0');
        const SSS = String(now.getMilliseconds()).padStart(3, '0');
        const timestamp = `${hh}-${mm}-${ss}-${SSS}`;
        const zipFilename = `${baseName}-${timestamp}.zip`;
        const txtFilename = `${baseName}.txt`;

        zip.file(txtFilename, textContent);
        // Generate the ZIP blob and trigger download
        zip.generateAsync({ type: "blob" }).then(blob => {
            const url = URL.createObjectURL(blob);
            const dlAnchor = document.createElement('a');
            dlAnchor.href = url;
            dlAnchor.download = zipFilename;
            document.body.appendChild(dlAnchor);
            dlAnchor.click();
            document.body.removeChild(dlAnchor);
            URL.revokeObjectURL(url);
        }).catch(err => {
            console.error("ZIP generation failed:", err);
        });
    }

    // Placeholder: the actual AI summarization function (to be implemented or integrated)
    // This should take the filtered conversation data and return either a string or an object with summary sections.
    async function summarizeConversation(convoData) {
        // For demonstration, we assume there's an AI endpoint or service we can call.
        // In practice, you would implement the API call to OpenAI or OpenPhone's AI here.
        // This dummy implementation just returns a stubbed summary.
        if (!convoData || convoData.length === 0) {
            return "(No data to summarize)";
        }
        // TODO: replace with real AI call. For now, return dummy structured summary:
        return {
            title: "Sample Conversation Summary",
            quickSummary: "This is a quick summary of the conversation.",
            detailedSummary: "This is a more detailed summary of the conversation, covering main points and context.",
            actionItems: "Action Item 1: ...\nAction Item 2: ...",
        };
    }

    // Initialize: insert the Summarize button when applicable
    // We use a MutationObserver or interval to ensure we add the button when the conversation UI is present.
    const observer = new MutationObserver(() => {
        insertSummarizeButton();
    });
    observer.observe(document.body, { childList: true, subtree: true });
})();