// ==UserScript==
// @name         OpenPhone AI Summarizer (Exact Preview Models)
// @namespace    https://github.com/ilakskills/
// @version      68.0
// @description  Summarize threads with a user-specified list of Gemini preview models, integrated into the message hover menu.
// @author       ilakskills
// @match        https://my.openphone.com/inbox/*
// @grant        GM_addStyle
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_xmlhttpRequest
// @grant        GM_setClipboard
// ==/UserScript==

(function () {
  'use strict';

  // =============================================================================
  // C O N F I G U R A T I O N   &   C O N S T A N T S
  // =============================================================================

  const GEMINI_KEY_NAME = 'gemini_api_key_storage_tm';
  const AUTH_COOKIE_NAME = 'openphone_auth_token';

  // UPDATED: Uses the exact preview model IDs for the API call.
  const MODELS = [
    {
      id: 'gemini-2.5-pro',
      family: 'gemini',
      displayName: 'Gemini 2.5 Pro',
      description: 'Highest quality and reasoning for complex tasks.'
    },
    {
      id: 'gemini-2.5-flash',
      family: 'gemini',
      displayName: 'Gemini 2.5 Flash (Default)',
      description: 'Best balance of speed and power for daily use.'
    },
    {
      id: 'gemini-2.5-flash-lite',
      family: 'gemini',
      displayName: 'Gemini 2.5 Flash-Lite',
      description: 'A lighter, faster version for quick tasks.'
    }
  ];
  const DEFAULT_MODEL_ID = 'gemini-2.5-flash';

  const PROMPT_SECTIONS = {
    title: `Title:\nDescribe the main meeting purpose or project discussed. Use details from any provided images to be more specific (e.g., "Network Rack Installation", "Server Troubleshooting Session").`,
    attendees: `Attendees:\nList names, inferred roles, and companies. Use phone numbers if names are unavailable.`,
    project_topic: `Project/Topic:\nClearly state the main project or work order. Include relevant IDs (WO#, Ticket#) and describe equipment seen in images.`,
    discussion_points: `Content/Key Discussion Points:\nBulleted list summarizing the core conversation. Synthesize related points.`,
    decisions: `Decisions Made:\nBulleted list of explicit agreements or conclusions reached.`,
    action_items: `Follow-Up Tasks / Action Items:\nClear, actionable bullet points, assigned to a person/role with deadlines if mentioned.`,
    notes: `Notes/Observations (Optional):\nInclude observations about tone, potential risks, or unresolved questions.`,
    quick_summary: `Quick Summary: Sum it all up into 2 or 3 easy to understand sentences.`,
    quick_next_steps: `Quick Next Steps: Outline next steps in 2 or 3 easy to understand sentences.`,
    disclaimer: `Disclaimer:\n"Generated by AI. Please review for accuracy."`
  };
  const BASE_PROMPT_HEADER = `Goal:\nTransform a potentially messy conversation log (texts, voicemails, calls) into a clean, structured project summary that is immediately actionable.\nRules:\n- Be concise. Prefer bullets. Use clear labels.\n- Infer reasonable details (roles, companies) but avoid fabrications.\n- If images are provided, incorporate their descriptions.\n- Pull out IDs (Ticket/WO) and any dates/times.\n- Keep Quick Summary and Quick Next Steps short—2–3 sentences each.\n- The output format should follow the requested sections exactly.\n- Maintain a neutral, professional tone.\n`;
  const IMAGE_ANALYSIS_PROMPT = `You are an expert at analyzing technical images from the field. For EACH of the following image(s), provide a detailed, one-sentence 'description'.\nYour entire response MUST be ONLY a valid JSON object with an "image_details" array, with no other text before or after it.\n\nExample JSON format for 2 images:\n{\n  "image_details": [\n    { "description": "A technician is holding a newly installed network switch in a server rack." },\n    { "description": "A close-up of a network cable being plugged into a patch panel." }\n  ]\n}`;
  const ICONS = {
    sparkle: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2.5a.75.75 0 0 1 .75.75V5a.75.75 0 0 1-1.5 0V3.25A.75.75 0 0 1 12 2.5zm0 14a.75.75 0 0 1 .75.75v1.75a.75.75 0 0 1-1.5 0V17.5a.75.75 0 0 1 .75-.75zM6.22 5.47a.75.75 0 0 1 1.06 0l1.25 1.25a.75.75 0 0 1-1.06 1.06L6.22 6.53a.75.75 0 0 1 0-1.06zm8.94 8.94a.75.75 0 0 1 1.06 0l1.25 1.25a.75.75 0 0 1-1.06 1.06l-1.25-1.25a.75.75 0 0 1 0-1.06zM2.5 11.25a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5a.75.75 0 0 1 .75-.75zm18.5.75a.75.75 0 0 0 1.5 0v-1.5a.75.75 0 0 0-1.5 0v1.5zM6.22 15.22a.75.75 0 0 1 0-1.06l1.25-1.25a.75.75 0 0 1 1.06 1.06l-1.25 1.25a.75.75 0 0 1-1.06 0zM15.22 6.22a.75.75 0 0 1 0-1.06l1.25-1.25a.75.75 0 1 1 1.06 1.06l-1.25 1.25a.75.75 0 0 1-1.06 0z"/></svg>`,
    settings: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path fill="currentColor" d="M10.667 1.875A.833.833 0 0 0 10 1.25a.833.833 0 0 0-.667.625l-.234.937a5.218 5.218 0 0 0-1.593.84l-.87-.39a.833.833 0 0 0-.933.277L4.29 5.293a.833.833 0 0 0 .278.933l.794.516a5.233 5.233 0 0 0 0 1.916l-.794.516a.833.833 0 0 0-.278.933l1.414 1.414a.833.833 0 0 0 .933.278l.87-.39c.47.318.99.577 1.592.839l.234.937A.833.833 0 0 0 10 18.75a.833.833 0 0 0 .667-.625l-.234-.937c.603-.262 1.122-.521 1.593-.84l.87.39a.833.833 0 0 0 .933-.277l1.414-1.414a.833.833 0 0 0-.278-.933l-.794-.516a5.233 5.233 0 0 0 0-1.916l.794-.516a.833.833 0 0 0 .278-.933L15.707 3.88a.833.833 0 0 0-.933-.278l-.87.39a5.218 5.218 0 0 0-1.592-.84l-.234-.937zM10 12.5a2.5 2.5 0 1 1 0-5a2.5 2.5 0 0 1 0 5z"/></svg>`,
    send: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path fill="currentColor" d="M2.525 2.525a.75.75 0 0 1 .91-.073l13.5 6.75a.75.75 0 0 1 0 1.196l-13.5 6.75a.75.75 0 0 1-1.002-1.123L3.89 10 2.433 3.571a.75.75 0 0 1 .092-1.046z"/></svg>`,
  };

  // =============================================================================
  // H E L P E R   F U N C T I O N S
  // =============================================================================

  function gmFetch(url, options = {}) {
    return new Promise((resolve, reject) => {
      GM_xmlhttpRequest({
        method: options.method || 'GET', url, headers: options.headers, data: options.body, responseType: options.responseType,
        onload: (res) => {
          const response = { ok: res.status >= 200 && res.status < 300, status: res.status, statusText: res.statusText, url: res.finalUrl, headers: res.responseHeaders, json: async () => JSON.parse(res.responseText), text: async () => res.responseText, blob: async () => res.response, };
          resolve(response);
        },
        onerror: (err) => reject(new Error('GM_xmlhttpRequest network error')),
        ontimeout: () => reject(new Error('GM_xmlhttpRequest timeout')),
      });
    });
  }

  const markdownToHtml = (text) => {
    let html = (text ?? '').replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    html = html.replace(/^### (.*$)/gim, "<h3>$1</h3>").replace(/^## (.*$)/gim, "<h2>$1</h2>").replace(/^# (.*$)/gim, "<h1>$1</h1>").replace(/\*\*(.*?)\*\*|__(.*?)__/g, "<strong>$1$2</strong>").replace(/\*(.*?)\*|_(.*?)_/g, "<em>$1$2</em>").replace(/^\s*[-*] (.*)$/gim, "<ul><li>$1</li></ul>").replace(/<\/ul>\s*<ul>/g, "");
    return html.replace(/\n/g, "<br>");
  };

  // =============================================================================
  // A U T H E N T I C A T I O N   H A N D L I N G
  // =============================================================================

  const getCookie = (name) => {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
  };
  const setCookie = (name, value, days = 7) => {
    let expires = "";
    if (days) { const date = new Date(); date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); expires = "; expires=" + date.toUTCString(); }
    document.cookie = `${name}=${value || ""}${expires}; path=/`;
  };
  const getAuthToken = () => new Promise((resolve, reject) => {
    const cookieToken = getCookie(AUTH_COOKIE_NAME);
    if (cookieToken) return resolve(cookieToken);
    let capturedToken = null;
    const originalFetch = window.fetch;
    const originalSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
    const cleanupInterceptors = () => { window.fetch = originalFetch; XMLHttpRequest.prototype.setRequestHeader = originalSetRequestHeader; };
    window.fetch = function (...args) {
      const headers = args[1]?.headers;
      if (headers && (headers.Authorization || headers.authorization)) capturedToken = headers.Authorization || headers.authorization;
      return originalFetch.apply(this, args);
    };
    XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
      if (header && header.toLowerCase() === 'authorization') capturedToken = value;
      return originalSetRequestHeader.apply(this, arguments);
    };
    let attempts = 0;
    const interval = setInterval(() => {
      if (capturedToken) { clearInterval(interval); cleanupInterceptors(); setCookie(AUTH_COOKIE_NAME, capturedToken); resolve(capturedToken); }
      else if (attempts++ > 60) { clearInterval(interval); cleanupInterceptors(); reject(new Error("Auth token capture timed out. Please interact with the OpenPhone app (e.g., toggle a message's read status) to trigger a network request, then try again.")); }
    }, 250);
  });

  // =============================================================================
  // U I   C O M P O N E N T S
  // =============================================================================

  const injectStyles = () => { GM_addStyle(`.ai-summarizer-root .modal-overlay{position:fixed!important;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.5);z-index:999998!important;display:flex;align-items:center;justify-content:center;user-select:text;-webkit-user-select:text}.ai-summarizer-root .modal-content{background:#fff;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,.25);width:90%;max-width:800px;max-height:90vh;display:flex;flex-direction:column}.ai-summarizer-root .modal-header{padding:16px;border-bottom:1px solid #e0e0e0;display:flex;justify-content:space-between;align-items:center}.ai-summarizer-root .modal-header h2{margin:0;font-size:18px;color:#333}.ai-summarizer-root .modal-close{font-size:24px;font-weight:700;cursor:pointer;color:#888;border:none;background:0 0}.ai-summarizer-root .modal-body{padding:16px;overflow-y:auto;font-family:sans-serif;flex-grow:1;line-height:1.5;white-space:normal;background-color:#fff}.ai-summarizer-root .modal-footer{padding:12px 16px;border-top:1px solid #e0e0e0;display:flex;gap:10px;justify-content:flex-end}.ai-summarizer-root .modal-button{padding:8px 16px;border-radius:6px;border:1px solid #ccc;background:#f0f0f0;cursor:pointer;font-weight:500}.ai-summarizer-root .modal-button:hover{background:#e0e0e0}.ai-summarizer-root .modal-button.primary{background:#007bff;color:#fff;border-color:#007bff}.ai-summarizer-root .modal-button.primary:hover{background:#0056b3}.ai-summarizer-root .toast{position:fixed!important;top:20px;right:20px;background:#333;color:#fff;padding:12px 20px;border-radius:6px;z-index:1000000!important;font-size:14px;transition:opacity .5s;opacity:1}.ai-summarizer-root .toast.error{background-color:#d9534f}.ai-summarizer-root .settings-section{margin-bottom:20px}.ai-summarizer-root .settings-section h3{margin:0 0 10px;border-bottom:1px solid #eee;padding-bottom:5px}.ai-summarizer-root .settings-section label{display:block;margin-bottom:5px;font-weight:700}.ai-summarizer-root .settings-section input[type=text],.ai-summarizer-root .settings-section textarea{width:100%;padding:8px;box-sizing:border-box;border:1px solid #ccc;border-radius:4px;font-family:sans-serif}.ai-summarizer-root .model-selection-grid,.ai-summarizer-root .sections-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}.ai-summarizer-root .model-desc{font-size:12px;color:#666;padding-left:25px;margin-top:-5px}.ai-summarizer-root .chat-log{display:flex;flex-direction:column;gap:12px}.ai-summarizer-root .message-bubble{padding:10px 14px;border-radius:18px;max-width:80%;line-height:1.5;white-space:pre-wrap;word-break:break-word}.ai-summarizer-root .message-bubble.user{background:#007bff;color:#fff;align-self:flex-end}.ai-summarizer-root .message-bubble.model{background:#e9e9eb;color:#1c1c1e;align-self:flex-start}.ai-summarizer-root .message-bubble.loading{align-self:flex-start;font-style:italic;color:#555}.ai-summarizer-root .message-bubble.error{background:#ffcccc;color:#a00}.ai-summarizer-root .chat-input-form{display:flex;gap:10px;padding:10px 16px;border-top:1px solid #e0e0e0}.ai-summarizer-root #chat-input{flex-grow:1;padding:10px;border:1px solid #ccc;border-radius:20px}.ai-summarizer-root #chat-send-btn{background:#007bff;color:#fff;border:none;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;cursor:pointer;flex-shrink:0}`);};
  const showToast = (message, type = 'success') => {
    const toast = document.createElement('div'); toast.className = `toast ${type}`; toast.textContent = message; const root = document.querySelector('.ai-summarizer-root') || document.body; root.appendChild(toast); setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 500); }, 3000);
  };
  const manageApiKeys = async () => {
    const geminiKey = await GM_getValue(GEMINI_KEY_NAME, ""); const newGeminiKey = prompt("Enter your Google AI (Gemini) API Key:", geminiKey); if (newGeminiKey !== null) { await GM_setValue(GEMINI_KEY_NAME, newGeminiKey.trim()); showToast("API Key updated!", "success"); }
  };
  const copyRichText = (htmlContent, plainTextContent) => {
    try { const blobHtml = new Blob([htmlContent], { type: "text/html" }); const blobText = new Blob([plainTextContent], { type: "text/plain" }); const item = new ClipboardItem({ "text/html": blobHtml, "text/plain": blobText }); navigator.clipboard.write([item]).then(() => showToast("Formatted summary copied!")).catch(err => { console.error("Rich text copy failed, falling back to plain text:", err); GM_setClipboard(plainTextContent, "text"); showToast("Copied as plain text."); }); } catch (e) { console.error("ClipboardItem not supported, falling back to plain text:", e); GM_setClipboard(plainTextContent, "text"); showToast("Copied as plain text."); }
  };
  const showExecutionOptionsModal = () => {
    const modal = document.createElement("div"); modal.className = "modal-overlay options-modal";
    const defaultSections = ["title", "quick_summary", "quick_next_steps"];
    const sectionsHtml = Object.keys(PROMPT_SECTIONS).map(key => `<label><input type="checkbox" name="section" value="${key}" ${defaultSections.includes(key) ? "checked" : ""}>${key.replace(/_/g, " ").replace(/\b\w/g, c => c.toUpperCase())}</label>`).join("");
    const modelsHtml = MODELS.map(m => `<div><label><input type="radio" name="model" value="${m.id}" ${m.id === DEFAULT_MODEL_ID ? "checked" : ""}> ${m.displayName}</label><div class="model-desc">${m.description}</div></div>`).join("");
    modal.innerHTML = `<div class="modal-content"><div class="modal-header"><h2>Generate Summary Options</h2><button class="modal-close">×</button></div><div class="modal-body"><div class="settings-section"><h3>Custom Instructions (One-time)</h3><textarea id="custom-instructions" rows="3" placeholder="e.g., Act as a project manager. Focus on billing issues."></textarea></div><div class="settings-section"><h3>AI Model</h3><div class="model-selection-grid">${modelsHtml}</div></div><div class="settings-section"><h3>Output Sections</h3><div class="sections-grid">${sectionsHtml}</div></div></div><div class="modal-footer"><button class="modal-button" id="cancel-run">Cancel</button><button class="modal-button primary" id="generate-summary">Generate Summary</button></div></div>`;
    document.querySelector('.ai-summarizer-root').appendChild(modal);
    const close = () => modal.remove();
    modal.querySelector(".modal-close").addEventListener("click", close); modal.querySelector("#cancel-run").addEventListener("click", close);
    modal.querySelector("#generate-summary").addEventListener("click", () => {
      const selectedModel = modal.querySelector('input[name="model"]:checked').value; const selectedSections = Array.from(modal.querySelectorAll('input[name="section"]:checked')).map(cb => cb.value); const customInstructions = modal.querySelector("#custom-instructions").value;
      if (selectedSections.length === 0) return showToast("Please select at least one output section.", "error");
      close(); runSummaryProcess(selectedModel, selectedSections, customInstructions);
    });
  };
  const showChatModal = (initialHistory, modelId) => {
    let chatHistory = [...initialHistory]; const modal = document.createElement("div"); modal.className = "modal-overlay chat-modal";
    modal.innerHTML = `<div class="modal-content"><div class="modal-header"><h2>AI Summary & Refinement</h2><button class="modal-close">×</button></div><div class="modal-body"><div class="chat-log"></div></div><form class="chat-input-form"><input type="text" id="chat-input" placeholder="Refine the summary..." autocomplete="off"><button type="submit" id="chat-send-btn" title="Send">${ICONS.send}</button></form><div class="modal-footer"><button class="modal-button primary copy-btn">Copy Summary</button></div></div>`;
    document.querySelector('.ai-summarizer-root').appendChild(modal);
    const chatLog = modal.querySelector(".chat-log"); const chatInput = modal.querySelector("#chat-input"); const chatForm = modal.querySelector(".chat-input-form");
    const appendMessage = (sender, text) => { const bubble = document.createElement("div"); bubble.className = `message-bubble ${sender}`; bubble.innerHTML = sender === "model" ? markdownToHtml(text) : (text || ""); chatLog.appendChild(bubble); chatLog.scrollTop = chatLog.scrollHeight; return bubble; };
    const initialSummary = chatHistory.find(h => h.role === "model")?.parts?.[0]?.text;
    if (initialSummary) appendMessage("model", initialSummary);
    const sendChatMessage = async (message) => {
      appendMessage("user", message); chatInput.value = ""; const loadingBubble = appendMessage("model loading", "…"); chatHistory.push({ role: "user", parts: [{ text: message }] });
      try { const responseText = await callAiModel({ modelId, chatHistory }); if (!responseText) throw new Error("Received an empty response from the AI."); chatHistory.push({ role: "model", parts: [{ text: responseText }] }); loadingBubble.remove(); appendMessage("model", responseText); }
      catch (error) { loadingBubble.remove(); appendMessage("error", `Error: ${error.message}`); console.error("Chat refinement error:", error); }
    };
    chatForm.addEventListener("submit", (e) => { e.preventDefault(); const msg = chatInput.value.trim(); if(msg) sendChatMessage(msg); });
    const close = () => modal.remove();
    modal.querySelector(".modal-close").addEventListener("click", close);
    modal.querySelector(".copy-btn").addEventListener("click", () => { const lastModelMessage = chatLog.querySelector(".message-bubble.model:last-child"); if (lastModelMessage) copyRichText(lastModelMessage.innerHTML, lastModelMessage.textContent); });
  };

  // =============================================================================
  // C O R E   L O G I C
  // =============================================================================

  const buildDynamicPrompt = (selectedSections, customInstructions, imageInfo = []) => {
    let finalPrompt = ""; if (customInstructions?.trim()) finalPrompt += `SPECIAL ONE-TIME INSTRUCTION:\n${customInstructions.trim()}\n\n---\n\n`; if (imageInfo.length > 0) finalPrompt += `--- AI-GENERATED IMAGE DESCRIPTIONS ---\n${imageInfo.map(i => `- ${i.description}`).join("\n")}\n\n---\n\n`; let formatInstructions = ""; selectedSections.forEach(key => { if (PROMPT_SECTIONS[key]) formatInstructions += PROMPT_SECTIONS[key] + "\n"; }); return finalPrompt + BASE_PROMPT_HEADER + "\n" + formatInstructions;
  };
  async function fetchOpenPhoneData(conversationId, authToken) {
    const apiUrl = `https://communication.openphoneapi.com/v2/activity?id=${conversationId}&last=101`; const response = await gmFetch(apiUrl, { headers: { Authorization: authToken } }); if (response.status === 401) { setCookie(AUTH_COOKIE_NAME, "", -1); throw new Error("Authorization token expired. Please toggle a message's read status to refresh it, then try again."); } if (!response.ok) throw new Error(`Failed to fetch OpenPhone data (Status: ${response.status})`); return await response.json();
  }
  async function analyzeImages(conversationActivities, geminiKey) {
      const imageItems = (conversationActivities || []).flatMap(a => a.media || []).filter(m => m?.type?.startsWith("image/")); if (imageItems.length === 0) return { imageInfo: [], imagePayloads: [] }; showToast(`Found ${imageItems.length} image(s). Analyzing…`);
      const toDataUrl = async (url) => { try { const res = await gmFetch(url, { responseType: 'blob' }); if (!res.ok) throw new Error(`Fetch failed for ${url}`); const blob = await res.blob(); return await new Promise(resolve => { const reader = new FileReader(); reader.onloadend = () => resolve({ mime: blob.type, dataUrl: reader.result }); reader.readAsDataURL(blob); }); } catch (e) { console.error("Skipping image due to fetch error:", e); return null; } };
      const imagePayloads = (await Promise.all(imageItems.map(item => toDataUrl(item.url)))).filter(Boolean); if (imagePayloads.length === 0) return { imageInfo: [], imagePayloads: [] };
      const parts = [{ text: IMAGE_ANALYSIS_PROMPT }, ...imagePayloads.map(p => ({ inlineData: { mimeType: p.mime, data: p.dataUrl.split(",")[1] } }))]; const payload = { contents: [{ role: "user", parts }] }; const analysisApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiKey}`; const response = await gmFetch(analysisApiUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) }); let imageInfo = [];
      if (response.ok) { const json = await response.json(); const textResponse = json.candidates?.[0]?.content?.parts?.[0]?.text || ''; try { const metadata = JSON.parse(textResponse.replace(/```json|```/g, '')); imageInfo = metadata.image_details || []; showToast("Image analysis complete."); } catch (e) { console.error("Failed to parse image analysis JSON:", e); showToast("Image analysis parsing failed.", "error"); } } else { console.warn("Image analysis API call failed:", await response.text()); showToast("Image analysis failed; continuing without descriptions.", "error"); } return { imageInfo, imagePayloads };
  }
  async function callAiModel({ modelId, prompt, jsonData, imagePayloads = [], chatHistory = [] }) {
    const apiKey = await GM_getValue(GEMINI_KEY_NAME); if (!apiKey) throw new Error("Gemini API Key is not set.");
    const apiVersion = 'v1beta'; // Force v1beta endpoint for all calls
    const url = `https://generativelanguage.googleapis.com/${apiVersion}/models/${modelId}:generateContent?key=${apiKey}`;
    let contents;
    if (chatHistory.length > 0) {
      contents = chatHistory;
    } else {
      const textContent = `${prompt}\n\n--- JSON DATA TO ANALYZE ---\n${JSON.stringify(jsonData, null, 2)}`;
      const textPart = { text: textContent };
      const imageParts = imagePayloads.map(p => ({ inlineData: { mimeType: p.mime, data: p.dataUrl.split(",")[1] } }));
      contents = [{ role: "user", parts: [textPart, ...imageParts] }];
    }
    const response = await gmFetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ contents }) });
    if (!response.ok) throw new Error(`Gemini API Error: ${await response.text()}`);
    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text;
  }
  const runSummaryProcess = async (modelId, selectedSections, customInstructions) => {
    showToast("Starting summary process…");
    try {
      const authToken = await getAuthToken(); const conversationId = window.location.href.split("/").find(p => p.startsWith("CN")); if (!conversationId) throw new Error("Could not find a valid Conversation ID in the URL."); showToast("Fetching conversation data…"); const openPhoneData = await fetchOpenPhoneData(conversationId, authToken); if (!openPhoneData?.result?.length) return showToast("No activities found in this conversation.", "error"); const geminiKey = await GM_getValue(GEMINI_KEY_NAME); const { imageInfo, imagePayloads } = await analyzeImages(openPhoneData.result, geminiKey); showToast("Generating summary…"); const dynamicPrompt = buildDynamicPrompt(selectedSections, customInstructions, imageInfo); const responseText = await callAiModel({ modelId, prompt: dynamicPrompt, jsonData: openPhoneData, imagePayloads }); if (!responseText) throw new Error("The AI returned an empty response.");
      const initialHistory = [ { role: "user", parts: [{ text: `Initial Prompt: ${dynamicPrompt}` }] }, { role: "model", parts: [{ text: responseText }] }, ];
      showChatModal(initialHistory, modelId);
    } catch (error) { console.error("❌ Summary Process Failed:", error); showToast(error.message, "error"); }
  };
  const addSummarizerButtonToMenu = (menu) => {
    const button = document.createElement('button'); button.id = 'ai-summary-menu-btn'; button.className = 'xtabak0 xtabak6 xtabaka xtabakd xtabakf xtabakh'; button.style.cssText = 'background-color: transparent; width: 30px; height: 30px; font-size: 20px; border: none;'; button.innerHTML = ICONS.sparkle; button.addEventListener('click', (e) => { e.stopPropagation(); showExecutionOptionsModal(); });
    const tooltipDiv = document.createElement('div'); tooltipDiv.className = '_3heux70'; tooltipDiv.innerHTML = `<span>AI Summary</span>`; menu.appendChild(button); menu.appendChild(tooltipDiv);
  };

  // =============================================================================
  // I N I T I A L I Z A T I O N
  // =============================================================================

  function initialize() {
    console.log("🚀 Initializing OpenPhone AI Summarizer…");
    const rootEl = document.createElement('div'); rootEl.className = 'ai-summarizer-root'; document.body.appendChild(rootEl);
    injectStyles();
    const settingsButton = document.createElement('button'); settingsButton.innerHTML = ICONS.settings; settingsButton.title = "API Key Settings"; settingsButton.addEventListener('click', manageApiKeys); settingsButton.style.cssText = 'position:fixed; bottom:30px; right:30px; z-index:99999; background:#6c757d; color:white; border:0; border-radius:50%; width:40px; height:40px; cursor:pointer; display:flex; align-items:center; justify-content:center; box-shadow:0 2px 8px rgba(0,0,0,0.3);'; rootEl.appendChild(settingsButton);
    setInterval(() => {
        const menus = document.querySelectorAll('#message-quick-actions:not([data-summarizer-button-injected])');
        menus.forEach(menu => { menu.setAttribute('data-summarizer-button-injected', 'true'); addSummarizerButtonToMenu(menu); });
    }, 500);
    console.log("✅ AI Summarizer is now polling for message menus.");
  }

  initialize();

})();
