// ==UserScript==
// @name         WorkMarket Tech Analyzer & Sorter (v4.7 - Prioritize Quality & Reliability)
// @namespace    http://tampermonkey.net/
// @version      4.7
// @description  Fully automates analysis on the Talent tab. Heavily weights recent experience, but severely penalizes proven unreliability with your company.
// @author       Your Name
// @match        https://www.workmarket.com/assignments/details/*
// @grant        GM_addStyle
// @grant        GM_xmlhttpRequest
// ==/UserScript==

(function() {
    'use strict';

    console.log('WorkMarket Tech Analyzer v4.6 (Prioritize Quality & Reliability): Script loaded.');

    // --- CONFIGURATION ---
    const SCORING_CONFIG = {
        WEIGHTS: {
            // A small initial bonus just for having worked with you, to ensure they get rated.
            hasHistoryWithCompanyBonus: 250,

            // YOURS 3 MO. STATS (HEAVILY WEIGHTED - Reward recent success with you)
            satisfactionYours3Mo: 600,
            onTimeYours3Mo: 400,
            completedWorkYours3Mo: 15, // Logarithmic scaling

            // OTHER STATS (Less important than your specific experience)
            satisfactionAll: 150,
            onTimeAll: 100,
            completedWorkAll: 2,
            hasMessage: 20,

            // TRUST & PROFESSIONALISM BONUSES
            hasBackgroundCheck: 75,
            hasInsurance: 50,

            // STANDARD PENALTIES (Per incident)
            cancellationsAll: -20,
            cancellationsYours: -40,
            abandonedAll: -60,
            abandonedYours: -120, 
        },
        // --- RELATIONSHIP HEALTH PENALTIES (The "Human" Logic) ---
        // These are large, flat penalties applied if a relationship is fundamentally unhealthy.
        RELATIONSHIP: {
            // Severe penalty for abandoning a job with your company (Trust Violation)
            trustViolationPenalty: -1000, 

            // If a tech's total ON-TIME % with YOU is below this threshold (85%)
            poorOnTimeThresholdPercent: 0.85, 
            poorOnTimePenalty: -300,

            // If a tech's total CANCELLATIONS with YOU is above this count (3 incidents)
            excessiveCancellationsThreshold: 3,
            excessiveCancellationsPenalty: -250,
        },
        // --- DYNAMIC SCORING PARAMETERS ---
        DISTANCE: {
            penaltyPerMile: -1.5,
            sweetSpotMiles: 25, // No penalty for techs within this distance
            maxPenalty: -150,   // Cap the distance penalty
        },
        PRICE: {
            penaltyPerDollarOver: -2,
            bonusPercentOfSavings: 0.5, // 50 points per $100 saved
            maxBonus: 75,
        },
    };
    const INVITED_ONLY_PENALTY = -10000;

    // --- STYLING (Remains the same) ---
    GM_addStyle(`
        #wm-analyzer-status { background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 5px; font-size: 16px; margin: 10px 0; text-align: center; transition: background-color 0.5s ease; }
        .profile-card--details { display: flex !important; flex-wrap: wrap; justify-content: space-between; }
        .score-card.profile-card--score-card { flex: 1 1 300px; min-width: 280px; }
        .wm-analyzer-box { flex: 1 1 300px; min-width: 280px; border: 2px solid #007bff; border-radius: 8px; padding: 10px; margin: 10px; background-color: #f0f8ff; }
        .wm-analyzer-box.invited-card { border-color: #6c757d; background-color: #f8f9fa; }
        .wm-analyzer-box h3 { margin-top: 0; margin-bottom: 10px; font-size: 16px; border-bottom: 1px solid #ccc; padding-bottom: 5px; color: #0056b3; }
        .wm-analyzer-box.invited-card h3 { color: #5a6268; }
        .wm-analyzer-box .score { font-weight: bold; font-size: 22px; padding: 5px 12px; border-radius: 5px; color: white; display: inline-block; margin-bottom: 10px; }
        .wm-analyzer-box .details pre { margin: 4px 0; white-space: pre-wrap; font-family: inherit; font-size: 13px; }
    `);

    let analysisHasRun = false;

    // --- MAIN ANALYSIS FUNCTIONS ---

    function runAnalysis() {
        if(document.querySelector('#wm-analyzer-status')?.textContent.startsWith('Analyzing')) return;
        const statusDiv = document.getElementById('wm-analyzer-status');
        statusDiv.textContent = 'Fetching worker data...';
        statusDiv.style.backgroundColor = '#ffc107';

        const match = window.location.pathname.match(/\/assignments\/(?:details\/)?(\d+)/);
        if (!match) { statusDiv.textContent = 'Error: No ID Found'; return; }
        const assignmentId = match[1];
        const apiUrl = `/assignments/${assignmentId}/workers?start=0&limit=1000&sortColumn=NEGOTIATION_CREATED_ON&sortDirection=DESC`;

        GM_xmlhttpRequest({
            method: "GET", url: `https://www.workmarket.com${apiUrl}`,
            headers: { "Accept": "application/json" },
            onload: function(response) {
                try {
                    const data = JSON.parse(response.responseText);
                    if (data && data.results) {
                        statusDiv.textContent = `Analyzing ${data.results.length} workers...`;
                        processAndDisplayData(data.results);
                        statusDiv.textContent = 'Analysis Complete!';
                        statusDiv.style.backgroundColor = '#28a745';
                    } else { throw new Error('API data invalid.'); }
                } catch (e) {
                    console.error('WorkMarket Analyzer Error:', e);
                    statusDiv.textContent = 'Error: Could not parse worker data.';
                    statusDiv.style.backgroundColor = '#dc3545';
                }
            },
            onerror: function(response) {
                console.error('WorkMarket Analyzer Error:', response);
                statusDiv.textContent = 'Error: API Request Failed.';
                statusDiv.style.backgroundColor = '#dc3545';
            }
        });
    }

    function processAndDisplayData(workers) {
        document.querySelectorAll('.wm-analyzer-box').forEach(box => box.remove());
        const budget = getBudget();
        let applicants = [];
        let nonApplicants = [];
        
        workers.forEach(tech => {
            const { score, analysis, isApplicant } = calculateScore(tech, budget);
            if (isApplicant) applicants.push({ ...tech, rawScore: score, analysis });
            else nonApplicants.push({ ...tech, rawScore: INVITED_ONLY_PENALTY, analysis: "Invited Only" });
        });

        // Calculate relative scores based only on applicants' range
        const rawScores = applicants.length > 0 ? applicants.map(t => t.rawScore) : [0];
        const minScore = Math.min(...rawScores);
        const maxScore = Math.max(...rawScores);
        const scoreRange = maxScore > minScore ? maxScore - minScore : 1;

        applicants.forEach(tech => {
            // Normalize score to 0-100 scale
            tech.relativeScore = Math.round(((tech.rawScore - minScore) / scoreRange) * 100);
            displayResults(tech, true);
        });

        nonApplicants.forEach(tech => {
            tech.relativeScore = tech.rawScore; // Use raw score to keep invited techs at the bottom
            displayResults(tech, false);
        });

        setTimeout(sortWorkerCards, 500);
    }

    function getBudget() {
        const budgetElement = document.querySelector('#pricing-details strong');
        try { return parseFloat(budgetElement.textContent.trim().replace(/[^0-9.]/g, '')); } catch (e) { return null; }
    }

    // --- CORE SCORING LOGIC ---
    function calculateScore(tech, budget) {
        const isApplicant = tech.status === 'open' && tech.has_negotiation === true;
        if (!isApplicant) return { score: 0, analysis: "Invited Only", isApplicant: false };

        let score = 0;
        let analysis = [];
        const W = SCORING_CONFIG.WEIGHTS;
        const R = SCORING_CONFIG.RELATIONSHIP;
        const allStats = tech.resource_scorecard?.values;
        const yourStats = tech.resource_scorecard_for_company?.values;
        const negotiation = tech.negotiation;

        // --- RELATIONSHIP HEALTH CHECK (THE NEW LOGIC) ---
        const hasHistory = yourStats?.COMPLETED_WORK?.all > 0;
        if (hasHistory) {
            score += W.hasHistoryWithCompanyBonus;
            analysis.push(`ðŸ¤ History w/ You: +${W.hasHistoryWithCompanyBonus}`);

            // 1. TRUST VIOLATION: Abandoned jobs for you?
            if (yourStats?.ABANDONED_WORK?.all > 0) {
                score += R.trustViolationPenalty;
                analysis.push(`ðŸš¨ TRUST VIOLATION (Abandoned for You): ${R.trustViolationPenalty}`);
            }
            
            // 2. POOR RELIABILITY: Low on-time percentage with you?
            if (yourStats?.ON_TIME_PERCENTAGE?.all && yourStats.ON_TIME_PERCENTAGE.all < R.poorOnTimeThresholdPercent) {
                score += R.poorOnTimePenalty;
                analysis.push(`ðŸš¨ POOR ON-TIME % (for You): ${R.poorOnTimePenalty}`);
            }
            
            // 3. EXCESSIVE CANCELLATIONS: Too many cancellations with you?
            if (yourStats?.CANCELLED_WORK?.all > R.excessiveCancellationsThreshold) {
                score += R.excessiveCancellationsPenalty;
                analysis.push(`ðŸš¨ EXCESSIVE CANCELLATIONS (for You): ${R.excessiveCancellationsPenalty}`);
            }
        }

        // --- YOUR RECENT STATS (PRIMARY) ---
        if (yourStats?.SATISFACTION_OVER_ALL?.net90) { score += yourStats.SATISFACTION_OVER_ALL.net90 * W.satisfactionYours3Mo; analysis.push(`â­ Your Sat (3 Mo): +${Math.round(yourStats.SATISFACTION_OVER_ALL.net90 * W.satisfactionYours3Mo)}`); }
        if (yourStats?.ON_TIME_PERCENTAGE?.net90) { score += yourStats.ON_TIME_PERCENTAGE.net90 * W.onTimeYours3Mo; analysis.push(`â­ Your On-Time (3 Mo): +${Math.round(yourStats.ON_TIME_PERCENTAGE.net90 * W.onTimeYours3Mo)}`); }
        if (yourStats?.COMPLETED_WORK?.net90 > 0) { const bonus = Math.log(yourStats.COMPLETED_WORK.net90 + 1) * W.completedWorkYours3Mo; score += bonus; analysis.push(`â­ Your Jobs (3 Mo. - ${yourStats.COMPLETED_WORK.net90}): +${Math.round(bonus)}`); }

        // --- OVERALL STATS (SECONDARY) ---
        if (allStats?.SATISFACTION_OVER_ALL?.all) { score += allStats.SATISFACTION_OVER_ALL.all * W.satisfactionAll; analysis.push(`âœ… Overall Sat: +${Math.round(allStats.SATISFACTION_OVER_ALL.all * W.satisfactionAll)}`); }
        if (allStats?.ON_TIME_PERCENTAGE?.all) { score += allStats.ON_TIME_PERCENTAGE.all * W.onTimeAll; analysis.push(`âœ… Overall On-Time: +${Math.round(allStats.ON_TIME_PERCENTAGE.all * W.onTimeAll)}`); }
        if (allStats?.COMPLETED_WORK?.all > 0) { const bonus = Math.log(allStats.COMPLETED_WORK.all + 1) * W.completedWorkAll; score += bonus; analysis.push(`âœ… Overall Jobs (${allStats.COMPLETED_WORK.all}): +${Math.round(bonus)}`); }

        // --- TRUST & PROFESSIONALISM ---
        if(negotiation?.note){ score += W.hasMessage; analysis.push(`âœ… Has Message: +${W.hasMessage}`); }
        if(tech.is_background_checked){ score += W.hasBackgroundCheck; analysis.push(`âœ… Background Check: +${W.hasBackgroundCheck}`); }
        if(tech.has_insurance){ score += W.hasInsurance; analysis.push(`âœ… Has Insurance: +${W.hasInsurance}`); }

        // --- STANDARD PENALTIES (Applied per incident count) ---
        if (allStats?.ABANDONED_WORK?.all > 0) { score += allStats.ABANDONED_WORK.all * W.abandonedAll; analysis.push(`ðŸ”» Overall Abandoned (${allStats.ABANDONED_WORK.all}): ${Math.round(allStats.ABANDONED_WORK.all * W.abandonedAll)}`); }
        if (yourStats?.ABANDONED_WORK?.all > 0) { score += yourStats.ABANDONED_WORK.all * W.abandonedYours; analysis.push(`ðŸ”» YOUR Abandoned (${yourStats.ABANDONED_WORK.all}): ${Math.round(yourStats.ABANDONED_WORK.all * W.abandonedYours)}`); }
        if (allStats?.CANCELLED_WORK?.all > 0) { score += allStats.CANCELLED_WORK.all * W.cancellationsAll; analysis.push(`ðŸ”» Overall Canceled (${allStats.CANCELLED_WORK.all}): ${Math.round(allStats.CANCELLED_WORK.all * W.cancellationsAll)}`); }
        if (yourStats?.CANCELLED_WORK?.all > 0) { score += yourStats.CANCELLED_WORK.all * W.cancellationsYours; analysis.push(`ðŸ”» YOUR Canceled (${yourStats.CANCELLED_WORK.all}): ${Math.round(yourStats.CANCELLED_WORK.all * W.cancellationsYours)}`); }

        // --- DISTANCE PENALTY ---
        if (tech.distance > SCORING_CONFIG.DISTANCE.sweetSpotMiles) {
            const milesToPenalize = tech.distance - SCORING_CONFIG.DISTANCE.sweetSpotMiles;
            const penalty = Math.max(SCORING_CONFIG.DISTANCE.maxPenalty, milesToPenalize * SCORING_CONFIG.DISTANCE.penaltyPerMile);
            score += penalty;
            analysis.push(`ðŸ”» Distance (${tech.distance.toFixed(1)} mi): ${Math.round(penalty)}`);
        } else {
             analysis.push(`âœ… Distance OK (${tech.distance.toFixed(1)} mi)`);
        }

        // --- PRICE SCORING ---
        if (negotiation?.is_price_negotiation && budget) {
            const counterOffer = negotiation.pricing?.spend_limit || 0;
            analysis.push(`ðŸ’° Counter: $${counterOffer.toFixed(2)}`);
            if (counterOffer > budget) {
                const overage = counterOffer - budget;
                const penalty = overage * SCORING_CONFIG.PRICE.penaltyPerDollarOver;
                score += penalty;
                analysis.push(`ðŸ”» Price Over ($${overage.toFixed(2)}): ${Math.round(penalty)}`);
            } else {
                const savings = budget - counterOffer;
                const bonus = Math.min(SCORING_CONFIG.PRICE.maxBonus, savings * SCORING_CONFIG.PRICE.bonusPercentOfSavings);
                score += bonus;
                analysis.push(`âœ… Price OK ($${savings.toFixed(2)} saved): +${Math.round(bonus)}`);
            }
        } else {
            analysis.push('ðŸ’° No Counter-offer');
        }

        return { score: Math.round(score), analysis: analysis.join('\n'), isApplicant: true };
    }


    // --- DISPLAY AND DOM MANIPULATION FUNCTIONS (Remain the same) ---

    function displayResults(tech, isApplicant) {
        const selector = `.profile-card--photo[data-usernumber="${tech.user_number}"]`;
        const photoDiv = document.querySelector(selector);
        if (!photoDiv) return;
        const workerCard = photoDiv.closest('.profile-card');
        if (!workerCard) return;
        const detailsContainer = workerCard.querySelector('.profile-card--details');
        if (!detailsContainer) return;
        workerCard.dataset.score = tech.relativeScore;
        const scoreBox = createAnalysisBox(tech, isApplicant);
        detailsContainer.appendChild(scoreBox);
    }

    function createAnalysisBox(tech, isApplicant) {
        const { relativeScore, rawScore, analysis, negotiation } = tech;
        const scoreBox = document.createElement('div');
        scoreBox.className = isApplicant ? 'wm-analyzer-box applied-card' : 'wm-analyzer-box invited-card';
        let scoreColor = isApplicant ? (relativeScore > 80 ? '#28a745' : relativeScore > 40 ? '#ffc107' : '#dc3545') : '#6c757d';
        let html = `<h3>Analyzer Score</h3><div class="score" style="background-color: ${scoreColor};">${relativeScore}</div>`;
        if (isApplicant) {
            html += `<div class="details"><strong>Breakdown (Raw: ${rawScore}):</strong><pre>${analysis}</pre></div>`;
            if (negotiation?.note) {
                const noteText = document.createElement('div');
                noteText.textContent = negotiation.note;
                html += `<div class="message"><strong>Message:</strong> ${noteText.innerHTML.replace(/\n/g, '<br>')}</div>`;
            }
        } else {
             html += `<div class="details" style="padding-top: 50px;"><p>Invited only. Not ranked.</p></div>`;
        }
        scoreBox.innerHTML = html;
        return scoreBox;
    }

    function sortWorkerCards() {
        const container = document.querySelector('.assignment-workers--feed');
        if (!container) return;
        // Sorts by score descending. Invited techs (score -10000) naturally fall to the bottom.
        const cards = Array.from(container.querySelectorAll('.profile-card'));
        cards.sort((a, b) => (parseInt(b.dataset.score, 10) || INVITED_ONLY_PENALTY) - (parseInt(a.dataset.score, 10) || INVITED_ONLY_PENALTY));
        cards.forEach(card => container.appendChild(card));
        console.log("WorkMarket Tech Analyzer: SUCCESS - Cards sorted.");
    }

    // --- INITIALIZATION AND OBSERVER FUNCTIONS (Remain the same) ---

    function initializeAutomation() {
        const workersTabContent = document.querySelector('#workers');
        if (!workersTabContent || document.querySelector('#wm-analyzer-status')) return;
        const statusDiv = document.createElement('div');
        statusDiv.id = 'wm-analyzer-status';
        statusDiv.textContent = 'Analyzer Ready';
        const toolbar = workersTabContent.querySelector('.assignment-workers--toolbar');
        if (toolbar) toolbar.parentNode.insertBefore(statusDiv, toolbar); else workersTabContent.prepend(statusDiv);
        const pageSizeDropdown = workersTabContent.querySelector('.assignment-workers--page-size .selectize-input');
        if (pageSizeDropdown) {
            statusDiv.textContent = 'Setting to "Show All"...';
            pageSizeDropdown.click();
            setTimeout(() => {
                const showAllOption = document.querySelector('.selectize-dropdown-content .option[data-value="1000"]');
                if (showAllOption) { showAllOption.click(); waitForListToReloadAndRun(); }
                else { runAnalysis(); }
            }, 200);
        } else { runAnalysis(); }
    }

    function waitForListToReloadAndRun() {
        const feed = document.querySelector('.assignment-workers--feed');
        if (!feed) return;
        document.getElementById('wm-analyzer-status').textContent = 'Loading all workers...';
        const listObserver = new MutationObserver((mutationsList, obs) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'childList' && mutation.addedNodes.length > 0 && feed.querySelector('.profile-card')) {
                    obs.disconnect();
                    runAnalysis();
                    return;
                }
            }
        });
        listObserver.observe(feed, { childList: true, subtree: true });
    }

    const pageObserver = new MutationObserver(() => {
        if (document.querySelector('#workers.wm-tab--content.-active') && !analysisHasRun) {
            analysisHasRun = true;
            initializeAutomation();
        } else if (!document.querySelector('#workers.wm-tab--content.-active') && analysisHasRun) {
            analysisHasRun = false;
            const statusDiv = document.querySelector('#wm-analyzer-status');
            if (statusDiv) statusDiv.remove();
        }
    });

    const targetNode = document.querySelector('.content .wm-tabs');
    if (targetNode) {
        pageObserver.observe(targetNode, { attributes: true, subtree: true, attributeFilter: ['class'] });
        if (document.querySelector('#workers.wm-tab--content.-active')) {
            analysisHasRun = true;
            initializeAutomation();
        }
    }
})();
